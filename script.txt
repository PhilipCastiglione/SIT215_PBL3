# Show title screen
Hi and welcome to our presentation of Problem Solving task 3: A game of Nim. Our group consists of Lee and Phil and today we'll be demonstrating our implementation of a program in which a human plays a game of Nim against an Artificial intelligence agent.

# Show how to play Nim
The game of Nim is a game where a board is setup with a number of rows or heaps of objects which for the sake of simplicity in this presentation we'll refer to as heaps and tiles.
In the game two players take turns in removing tiles from the board where a player can remove any number of tiles but from only one heap per turn.
In the standard game mode, the aim is to be the player who removes the last object left on the board.
In the alternate misere game mode the opposite is true where the aim is to force your opponent to be the one left to remove the last object from the board.

# Show skills Audit
Firstly we met for a chat after reading the problem material and decided to undertake a skills audit based off the problem requirements identifying the core skills we would need to be able to complete the task. We then did some research into how to solve the problem and looked at other peoples finished solutions.
We decided that using an implementation of the minimax algorithm in Ruby was the best way for us to complete the task.

# Show solution challenges
There are a few challenges in our solution; firstly the AI needs to be able to play the game against an unpredictable and often imperfect human opponent as opposed to playing against another AI opponent like itself.

Secondly, the solution needs to involve an interactive environment where both the human player and the AI can interact together.

And thirdly, the AI needs to recognise what game mode is being played, either the normal mode or misere mode, and adjust its strategy accordingly to give itself the best odds of winning the game.


# Show AI strategy

# Show solution diagram

# Show demonstration slide 1

# Show demonstration slide 2

# Show demonstration slide 3

# Show demonstration slide 4

# Show demonstration slide 5

# Show demonstration video

# Show limitations and constraints
Because we are computing the full graph of all possible moves from the initial game state, our approach is very computationally expensive. We accepted this tradeoff because of the limited number of heaps and tiles we knew we would be solving for.
If we wanted to extend our solution to account for larger numbers of heaps and tiles we would need to make some adjustments. The simplest of those would be to add alpha beta pruning to the minimax tree computation, and recalculate the tree after each move. An additional optimisation would be to hash each board state with the heap/tile state of the board and the current player's turn. Then, we could keep a single reference to a node referenced by this hashcode and only compute a single subtree from that point, as the subtree from this point would be identical regardless of where it is encountered in the tree.
Lastly, this isn't really a limitation of the solution but more of a general point. Because the game is deterministic and fully observable, the AI always makes the "correct" move, so Lee/Phil and I pretty much always end up losing, unless we're lucky with the starting situation and it's obvious how to get a guaranteed win.

# Show references and conclusion
A link to the GitHub repository containing some working documents, and code you saw, is provided in the video description. Thanks for watching.
